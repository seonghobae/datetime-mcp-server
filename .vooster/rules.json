{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD)\n\n## 1. Overview\n\nThis project aims to develop an MCP (Model Context Protocol) server that provides **pure date calculation tools** for LLMs. Instead of parsing natural language date expressions, this MCP server offers precise mathematical date operations that LLMs can call when they need accurate temporal calculations. The server implements the MCP protocol and provides various date/time calculation tools, formatting utilities, and simple note management functionality. Key features include current datetime retrieval, date arithmetic operations, business day calculations, timezone handling, and date range computations. The server is developed as a fork of [https://github.com/bossjones/datetime-mcp-server](https://github.com/bossjones/datetime-mcp-server) ([https://github.com/seonghobae/datetime-mcp-server](https://github.com/seonghobae/datetime-mcp-server)), with the goal of merging with the upstream repository. It is distributable as a Docker/Podman container and is designed for easy integration and operation by LLM DevOps engineers.\n\n## 2. Problem Statement\n\n1. LLMs need reliable, accurate date calculations but should not rely on built-in date logic that may be incorrect or inconsistent.\n2. For RAG queries involving time ranges, LLMs need precise date arithmetic tools to calculate \"3 months ago from today\" or \"next business day after 2024-12-25\".\n3. Re-implementing date calculation logic across teams leads to productivity loss and calculation errors, especially with edge cases like leap years, timezone transitions, and business day rules.\n\n## 3. Goals & Objectives\n\n- Primary Goal: Provide MCP protocol tools for precise date/time calculations that LLMs can call when needed. (No natural language parsing; only mathematical date operations.)\n- Secondary Goal: Offer comprehensive timezone, business day, and formatting support for enterprise use cases.\n- Success Metrics\n    - Tool response time ≤ 50ms (p95) - faster than parsing-based approaches\n    - Calculation accuracy 100% (mathematical precision, not parsing accuracy)\n    - GitHub ⭐ 50, 10 forks, 1 merged upstream PR\n\n## 4. Target Users\n\n### Primary Users\n\n- LLM DevOps / MLOps engineers: Enhance LLM capabilities with reliable date calculation tools\n\n### Secondary Users\n\n- Data scientists, backend developers, RAG solution vendors, enterprise developers needing precise temporal logic\n\n## 5. User Stories\n\n- As an LLM operator, I want the LLM to call precise date calculation tools so that it can provide accurate temporal information without hallucination.\n- As a search engineer, I want LLMs to calculate exact date ranges (e.g., \"90 days before 2024-07-15\") for precise query generation.\n- As a business application developer, I want reliable business day calculations that account for weekends and holidays.\n\n## 6. Feature Requirements\n\n### Core Features\n\n1. **MCP Protocol Resources**\n    - `datetime://current`: Returns the current date and time in multiple formats\n    - `datetime://timezone-info`: Returns current timezone information and offset\n    - `datetime://supported-timezones`: Lists all supported timezone identifiers\n\n    - Acceptance criteria: Resource listing returns all current note and datetime resources; datetime resources must include current, timezone-info, and supported-timezones.\n\n2. **MCP Date Calculation Tools**\n    - `get-current-datetime`: Get current date/time in specified timezone and format\n    - `calculate-date`: Add/subtract days, weeks, months, years from a given date\n    - `calculate-date-range`: Calculate start and end dates for periods like \"last 3 months\"\n    - `format-date`: Convert dates between different formats (ISO, RFC3339, Unix timestamp, etc.)\n    - `calculate-business-days`: Calculate business days between dates, excluding weekends and holidays\n\n    - Input example: `calculate-date-range(\"2024-07-15\", \"last\", 3, \"months\")` → Output: `{ \"start\": \"2024-04-15\", \"end\": \"2024-07-15\" }`\n    - Input example: `calculate-business-days(\"2024-12-20\", \"2024-12-31\", [\"2024-12-25\"])` → Output: `{ \"business_days\": 7 }`\n\n3. **Note Management Tools**\n    - `add-note`: Adds a new note with a name and content\n    - `get-note`: Retrieves a note by name\n    - `list-notes`: Lists all available notes\n    - `delete-note`: Removes a note by name\n\n4. **MCP Prompts for LLM Guidance**\n    - `datetime-calculation-guide`: Provides examples of when and how to use date calculation tools\n    - `business-day-rules`: Explains business day calculation rules and holiday handling\n    - `timezone-best-practices`: Guidelines for timezone-aware date operations\n\n5. **Advanced Features**\n    - Timezone-aware calculations with DST handling\n    - Customizable business day rules (different weekend patterns, holiday calendars)\n    - High-precision datetime operations for financial and scientific applications\n\n### Non-Core Features (Future)\n- SSE stream response option for bulk calculations\n- Custom holiday calendar management\n- Recurring date pattern calculations\n\n## 7. Non-Functional Requirements\n\n- **Performance**: p95 ≤ 50ms (faster than parsing-based approaches), linear scalability up to 1000 QPS\n- **Accuracy**: 100% mathematical precision for all date calculations (no parsing ambiguity)\n- **Security**: HTTPS required, input validation, OWASP Top10 compliance\n- **Usability**: Clear MCP tool signatures, comprehensive examples in prompts\n- **Scalability**: Multi-instance scale-out, stateless design\n- **Compatibility**: Python 3.12+, AMD64/ARM64 containers, MCP 1.0 protocol compliance\n\n## 8. Technical Considerations\n\n- **Architecture**: Pure Python MCP server implementation, asyncio-based\n- **MCP Protocol**: Implements resources, tools, and prompts interfaces (see `server.py`)\n- **Date Calculation Engine**: Uses Python standard library `datetime`, `zoneinfo`, and `calendar` for precise calculations\n- **No External Parsing**: No dateparser or NLP libraries - all operations are mathematical\n- **Note Management**: In-memory key-value storage for simple notes; extensible for persistent storage\n- **Tool Implementation**: All tools are deterministic mathematical functions with clear input/output contracts\n- **CLI Client**: Async Python client supporting tool invocation, Claude API integration, interactive chat loop (see `client.py`)\n- **Dependency Management**: Uses `uv`, `pydantic`, `dotenv`; minimal dependencies for reliability\n- **Examples & Tests**: Includes acceptance and integration tests (pytest), Makefile tasks for development\n\n## 9. Success Metrics & KPIs\n\n- **Technical KPIs**: p95 response time ≤ 50ms, 100% calculation accuracy, 99.9% availability\n- **Product KPIs**: 1M monthly tool calls (MAU)\n- **Community KPIs**: GitHub stars, number of submitted PRs\n\n## 10. Timeline & Milestones\n\n- 2025-07-15 M0: Requirements freeze, repository setup\n- 2025-08-15 M1: Core MCP tools implementation (get-current-datetime, calculate-date)\n- 2025-09-01 M2: Advanced tools (business days, timezone handling), CLI client beta\n- 2025-09-15 M3: Container image, comprehensive prompts, performance optimization\n- 2025-10-01 M4: Upstream PR submission and review, v1.0 release\n\n## 11. Risks & Mitigations\n\n- Library license changes → Use only standard library components, maintain MIT license\n- Timezone data updates → Regular Python updates, fallback to UTC for unknown zones\n- Upstream PR rejection → Maintain independent repository, demonstrate clear value proposition\n\n## 12. Future Extensions\n\n- Custom business day calendars for different countries/industries\n- Advanced recurring date calculations (e.g., \"third Friday of each month\")\n- Integration with external calendar systems (Google Calendar, Outlook)\n- GraphQL interface for complex date queries\n- Native LLM plugin support (e.g., OpenAI function calling)",
      "writedAt": "2025-07-11T09:27:15.167Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 총괄 요약\n- **프로젝트 개요**  \n  MCP(Model Context Protocol) 서버는 LLM이 필요할 때 호출할 수 있는 **순수 날짜 계산 도구**를 제공하는 MCP 프로토콜 기반 서버이다. 자연어 파싱 대신 정확한 수학적 날짜 연산을 제공하며, 기존 레포지토리(datetime-mcp-server)를 포크하여 표준 MCP 서버로 구현한다. Docker/Podman 이미지로 배포된다.  \n- **핵심 기술 스택**  \n  Python 3.12, MCP(Server/Client), Pydantic, datetime/zoneinfo/calendar (표준 라이브러리), asyncio, uv(패키지 관리)  \n- **주요 기술 목표**  \n  ‑ p95 ≤ 50 ms 응답 시간 (파싱 방식보다 빠름)  \n  ‑ 100% 수학적 정확도 (파싱 오류 없음)  \n  ‑ 무상태(stateless) 설계로 1000 QPS까지 선형 확장  \n- **중대한 기술 가정**  \n  ‑ 자연어 파싱 없음 - 모든 연산은 수학적 계산  \n  ‑ 표준 라이브러리 중심 설계로 의존성 최소화  \n  ‑ MCP 1.0 프로토콜 완전 준수  \n\n## 2. 기술 스택\n\n| 범주 | 기술 / 라이브러리 | 선정 이유 |\n| --- | --- | --- |\n| 언어 | Python 3.12 | 팀 역량, 풍부한 표준 날짜 라이브러리, 비동기 지원 |\n| MCP 프레임워크 | 자체 구현(server.py) | MCP 1.0 프로토콜 직접 구현, 오버엔지니어링 방지 |\n| MCP 프로토콜 | JSON-RPC over stdio/HTTP | 표준 MCP 통신 방식 |\n| 날짜 계산 | datetime, zoneinfo, calendar | 표준 라이브러리, 수학적 정확성, 외부 의존성 없음 |\n| 데이터 검증 | Pydantic v2 | 타입 변환, 스키마 검증, MCP 메시지 유효성 |\n| HTTP 클라이언트 | HTTPX | async/await 기반 SDK 구현에 적합 |\n| LLM 클라이언트 | anthropic | Claude API 통합, MCP 클라이언트 구현 |\n| 런타임 | asyncio | MCP 프로토콜의 비동기 특성에 최적화 |\n| 패키지 관리 | uv, pyproject.toml | monorepo, 잠금파일로 재현성 확보 |\n| 린팅/포매팅 | ruff | 빠른 Python 린터/포매터, Black/Flake8 대체 |\n| 타입 체킹 | pyright | Microsoft의 정적 타입 분석기, async 코드 지원 |\n| 코드 품질 | pre-commit | Git hooks를 통한 자동 코드 품질 검사 |\n| 컨테이너 | Dockerfile, Podman 호환 | 배포 표준화, CI/CD 용이 |\n| 테스트 | pytest, pytest-asyncio | 비동기 함수 테스트 지원 |\n| 테스트 플러그인 | pytest-cov, pytest-mock, pytest-httpx | 커버리지, 모킹, HTTP 테스트 지원 |\n| 테스트 커버리지 | coverage[toml] | 코드 커버리지 측정 및 리포팅 |\n| 다중 환경 테스트 | tox-uv | 여러 Python 버전에서 테스트 실행 |\n| CI/CD | GitHub Actions | 무료 러너, OSS 친화적 |\n| 문서화 | Markdown, MkDocs | 가벼운 정적 문서 사이트 생성 |\n\n## 3. 시스템 아키텍처 설계\n\n### 상위 빌딩 블록\n- **MCP Protocol Handler**  \n  JSON-RPC over stdio/HTTP를 통한 MCP 메시지 처리\n- **Date Calculation Service**  \n  표준 라이브러리 기반 순수 수학적 날짜 연산\n- **MCP Resource Provider**  \n  현재 시간, 타임존 정보, 지원 타임존 목록 제공\n- **MCP Tool Registry**  \n  날짜 계산, 포맷팅, 비즈니스 데이 계산 도구들\n- **Note Management Module**  \n  인-메모리 Dict로 간단한 노트 CRUD 제공\n- **Client SDK**  \n  MCP 프로토콜 기반 클라이언트 세션, 도구 호출 헬퍼\n- **CI/CD & 배포**  \n  GitHub Actions → Docker Hub 이미지 빌드·푸시\n\n### 상위 컴포넌트 상호작용 다이어그램\n```mermaid\ngraph TD\n    A[LLM Client] -->|MCP JSON-RPC| B[MCP Protocol Handler]\n    B -->|Tool Calls| C[Date Calculation Service]\n    B -->|Resource Requests| D[Resource Provider]\n    B -->|Note Operations| E[In-Memory Notes Store]\n    C -->|Mathematical Operations| F[datetime/zoneinfo/calendar]\n    B -->|MCP Responses| A\n```\n\n- LLM Client가 MCP 프로토콜로 도구 호출 요청  \n- MCP Protocol Handler가 요청을 적절한 서비스로 라우팅  \n- Date Calculation Service가 표준 라이브러리로 수학적 연산 수행  \n- 계산 결과를 MCP 응답으로 반환  \n\n### 코드 조직 & 컨벤션\n\n**도메인 중심 조직 전략**\n- **도메인 분리**: `datetime_tools`, `notes`, `protocol` 서브패키지로 경계 설정\n- **레이어 분리**: `mcp`(protocol) ↔ `services`(비즈니스) ↔ `tools`(계산)\n- **기능 기반 모듈**: 각 도메인 내부에 calculator, formatter, validator 동거\n- **공유 컴포넌트**: `common` 패키지에 유틸, 예외, 설정\n\n**디렉터리 구조**\n```\n/\n├── pyproject.toml\n├── README.md\n├── Dockerfile\n├── .github/\n│   └── workflows/ci.yml\n├── src/\n│   ├── datetime_mcp_server/\n│   │   ├── __init__.py\n│   │   ├── server.py         # MCP 프로토콜 구현\n│   │   ├── client.py         # MCP 클라이언트\n│   │   ├── tools/\n│   │   │   ├── datetime_tools.py\n│   │   │   ├── business_days.py\n│   │   │   └── formatters.py\n│   │   ├── services/\n│   │   │   ├── date_calculator.py\n│   │   │   └── note_service.py\n│   │   ├── resources/\n│   │   │   └── datetime_resources.py\n│   │   ├── prompts/\n│   │   │   └── datetime_prompts.py\n│   │   └── common/\n│   │       ├── config.py\n│   │       ├── schemas.py\n│   │       └── errors.py\n└── tests/\n    ├── test_tools.py\n    ├── test_calculations.py\n    └── test_mcp_protocol.py\n```\n\n### 데이터 흐름 & 통신 패턴\n- **LLM-서버 통신**  \n  MCP JSON-RPC over stdio → `call_tool(\"calculate-date\", {...})` → 수학적 날짜 계산 → JSON 응답  \n- **도구 호출 패턴**  \n  `calculate-date-range(\"2024-07-15\", \"last\", 3, \"months\")` → `{\"start\": \"2024-04-15\", \"end\": \"2024-07-15\"}`  \n- **저장소 인터랙션**  \n  노트 관리 시 `memory_store.NoteRepository` 호출, 앱 종료 시 데이터 휘발  \n- **외부 서비스 통합**  \n  없음(표준 라이브러리만 사용)  \n- **실시간 통신**  \n  향후 bulk 계산을 위한 스트림 옵션 고려  \n- **데이터 동기화**  \n  완전 무상태 설계, 인스턴스간 동기화 불필요  \n\n## 4. 성능 & 최적화 전략\n- 비동기 MCP 프로토콜 핸들링으로 동시성 극대화  \n- 계산 결과 LRU 캐싱(1K 엔트리)으로 반복 요청 응답 향상  \n- 표준 라이브러리 사용으로 파싱 오버헤드 제거  \n- pytest-benchmark로 회귀 성능 측정, p95 ≤ 50ms 자동 경고  \n- 수학적 연산만 수행하므로 CPU 효율성 극대화  \n\n## 5. MCP 도구 명세\n\n### Core Date Calculation Tools\n\n1. **get-current-datetime**\n   ```json\n   {\n     \"name\": \"get-current-datetime\",\n     \"description\": \"Get current date and time in specified timezone and format\",\n     \"inputSchema\": {\n       \"type\": \"object\",\n       \"properties\": {\n         \"timezone\": {\"type\": \"string\", \"default\": \"UTC\"},\n         \"format\": {\"type\": \"string\", \"enum\": [\"iso\", \"rfc3339\", \"unix\", \"readable\"]}\n       }\n     }\n   }\n   ```\n\n2. **calculate-date**\n   ```json\n   {\n     \"name\": \"calculate-date\", \n     \"description\": \"Add or subtract time from a date\",\n     \"inputSchema\": {\n       \"type\": \"object\",\n       \"properties\": {\n         \"base_date\": {\"type\": \"string\", \"format\": \"date\"},\n         \"operation\": {\"type\": \"string\", \"enum\": [\"add\", \"subtract\"]},\n         \"amount\": {\"type\": \"integer\"},\n         \"unit\": {\"type\": \"string\", \"enum\": [\"days\", \"weeks\", \"months\", \"years\"]}\n       },\n       \"required\": [\"base_date\", \"operation\", \"amount\", \"unit\"]\n     }\n   }\n   ```\n\n3. **calculate-date-range**\n   ```json\n   {\n     \"name\": \"calculate-date-range\",\n     \"description\": \"Calculate start and end dates for a time period\",\n     \"inputSchema\": {\n       \"type\": \"object\", \n       \"properties\": {\n         \"reference_date\": {\"type\": \"string\", \"format\": \"date\"},\n         \"direction\": {\"type\": \"string\", \"enum\": [\"last\", \"next\"]},\n         \"amount\": {\"type\": \"integer\"},\n         \"unit\": {\"type\": \"string\", \"enum\": [\"days\", \"weeks\", \"months\", \"years\"]}\n       },\n       \"required\": [\"reference_date\", \"direction\", \"amount\", \"unit\"]\n     }\n   }\n   ```\n\n4. **calculate-business-days**\n   ```json\n   {\n     \"name\": \"calculate-business-days\",\n     \"description\": \"Calculate business days between dates\",\n     \"inputSchema\": {\n       \"type\": \"object\",\n       \"properties\": {\n         \"start_date\": {\"type\": \"string\", \"format\": \"date\"},\n         \"end_date\": {\"type\": \"string\", \"format\": \"date\"},\n         \"holidays\": {\"type\": \"array\", \"items\": {\"type\": \"string\", \"format\": \"date\"}},\n         \"weekend_pattern\": {\"type\": \"string\", \"enum\": [\"sat-sun\", \"fri-sat\"], \"default\": \"sat-sun\"}\n       },\n       \"required\": [\"start_date\", \"end_date\"]\n     }\n   }\n   ```\n\n## 6. 구현 로드맵 & 마일스톤\n\n### Phase 1: 기초 (MVP)\n- MCP 프로토콜 핸들러, 기본 날짜 계산 도구 구현\n- get-current-datetime, calculate-date 도구 완성\n- 인-메모리 노트 CRUD, 표준 라이브러리 기반 계산 엔진\n- GitHub Actions: lint(pyright) + 테스트 + 이미지 빌드\n- 기간: 2025-08-15 (M1)\n\n### Phase 2: 고급 기능\n- calculate-date-range, calculate-business-days 도구 추가\n- 타임존 처리, 비즈니스 데이 규칙 구현\n- MCP 클라이언트 SDK, 종합적인 프롬프트 제공\n- 성능 최적화, 캐싱 시스템 도입\n- 기간: 2025-09-15 (M3)\n\n### Phase 3: 엔터프라이즈 기능\n- 고급 타임존 처리, DST 지원\n- 커스텀 비즈니스 데이 캘린더\n- 벌크 계산 최적화, 스트림 응답 베타\n- MCP 1.0 컴플라이언스 검증\n- 기간: 2025-10-01 (M4)\n\n## 7. 위험 평가 & 완화 전략\n\n### 기술 리스크\n- **표준 라이브러리 변경**: Python 버전 호환성 → LTS 버전 사용, 테스트 자동화  \n- **타임존 데이터 업데이트**: zoneinfo 데이터 변경 → 정기 Python 업데이트, UTC 폴백  \n- **성능 병목**: 대량 계산 요청 → 캐싱, 비동기 처리 최적화  \n- **MCP 프로토콜 변경**: MCP 스펙 업데이트 → 버전 호환성 유지, 점진적 마이그레이션  \n\n### 프로젝트 전달 리스크\n- **일정 지연**: Milestone별 PR 리뷰 체계화, 핵심 기능 우선순위  \n- **정확성 검증**: 수학적 계산 검증을 위한 포괄적 테스트 슈트  \n- **MCP 호환성**: MCP 1.0 스펙 준수 검증, 레퍼런스 구현과 비교  \n- **배포 실패**: 컨테이너 기반 배포, 단계적 롤아웃  \n\n---\n\n",
      "writedAt": "2025-07-11T09:27:15.167Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-11T09:27:15.167Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-11T09:27:15.167Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-11T09:27:15.167Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-11T09:27:15.167Z"
    }
  ]
}